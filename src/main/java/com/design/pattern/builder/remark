其实和模板模式非常的像，但是也有区别，那就是在模板模式中父类对子类中的实现进行操作，在父类之中进行一件事情的处理，
但是在Builder模式之中，父类和子类都不用关心怎么处理，而是用另一个类来完成对这些方法的有机组合，这个类的职责就是‘监工’，
规定了到底要怎么样有机的组合这些方法。在监工类（Director）中，将父类组合进去，然后调用父类的操作来抽象的实现一件事情，
这就是面向接口（抽象）编程的妙处了，


关于Builder模式，我们一定要分清和模板方法的区别，其实就是到底谁承担了“监工”的责任，在模板方法中父类承担了这个责任，
而在Builder中，有另外一个专门的类来完成这样的操作，这样做的好处是类的隔离，比如说在Main中，用户根本就不知道有Builder这个抽象类，
同样的Director这个监工的根本就不管到底是哪一个实现类，因为任何一个都会被转换为父类，然后进行处理（面向抽象编程的思想），
因此很好的实现了隔离，同样的这样设计的好处是复用了，隔离的越好复用起来就越方便，我们完全可以思考，假如还有另外一个监工，
使用了不同的construct方法来组装这些复杂的事件，那么对于原来的代码我们不用做任何的修改，只用增加这样的一个监工类，
然后定义好相应的方法就好了，之后再Main中使用，这样的一种思想使得我们不用修改源代码，复用（Builder以及其子类）就很方便了，
同样的，如果想增加一个新的Builder的子类，只要照着父类的方法进行填充，再加上自己的方法就好了，完全不用修改代码，这也是一种复用，
因此这种复用（组件）的思想在设计模式中随处可见，本质就是高内聚低耦合，组件开发，尽量不修改原来的代码，有可扩展性，理解了这一点，
我们再看看模板方法，责任全放在了父类里，如果责任需要改变，则必须要修改父类中的责任方法了，这样就修改了原来的代码，不利于复用，
这也是两者的本质区别。